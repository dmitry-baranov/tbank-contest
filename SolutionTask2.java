import java.util.Scanner;
import java.util.Stack;

/*
 * ## Задача 2

В самый что ни на есть обычный день Борис решил, 
что на протяжении следующих n дней он будет покупать своей маме букет 
ровно из трех цветов. Там, где живет Борис, существует всего лишь один магазин цветов, 
но зато в нем широкий ассортимент: для каждого і от 0 до 10^100 в магазине есть ровно 
один **уникальный** цветок, стоящий 2^i бурлей. К тому же в магазин ежедневно довозят цветы, 
которые были выкуплены.

В і-й день у Бориса есть аi бурлей, которые он готов потратить на букет. Борис хочет купить как
можно более дорогой букет. Для каждого из n дней определите, за какую стоимость Борис купит букет, 
или сообщите, что на его деньги невозможно купить никакой букет из трех цветов.

#### Формат входных данных
Первая строка содержит число n (1 ≤ n ≤ 10^5) — количество дней, в течение которых Борис 
планирует покупать букеты.

і-я из следующих n строк содержит число ai (1 ≤ ai ≤ 10^18) — количество бурлей, 
которое есть у Бориса в і-й день.

#### Формат выходных данных
Для каждого ai в отдельной строке выведите, сколько бурлей Борис потратит на 
букет в i-й день, или -1, если он не может купить никакой букет ровно из трех цветов.

Комменатрий к примеру

- в первый день Борис может купить цветы стоимостей 2^1, 2^2 и 2^3;
- во второй день борис может купить цветы стоимостей 2^0, 2^1 и 2^6;
- в третий день борис не может купить цветы таким образом, чтобы составить букет 
из трех цветов и уложиться в сумму в 5 бурлей.

### Примеры данных
#### Ввод
    3
    15
    67
    5
#### Вывод
    14
    67
    -1
---
 */
public class SolutionTask2 {
    public static void main(String[] args){
        try (Scanner scanner = new Scanner(System.in)) {
            int daysCount = scanner.nextInt();
            for(int i = 0; i<daysCount; i++){
                long burley = scanner.nextLong();
                System.out.println(howMuchBorisCanSpendMoney(burley));
            }
        }
    }

    private static long howMuchBorisCanSpendMoney(long burley){
        Stack<Integer> stack = new Stack<>();
        for(int i = 0; (1<<i) < burley; i++){
            if (((1<<i) & burley) != 0){
                stack.push(i);
            }
        }
        if(stack.size() < 3){
            return -1;
        }
        long result = (1<<stack.pop()) + (1<<stack.pop()) + (1<<stack.pop());
        return result;
    }
}